// package jitInboundService

// import (
// 	"encoding/json"
// 	"errors"
// 	"fmt"
// 	"jnv-jit/internal/db"
// 	"jnv-jit/internal/utils"
// 	"math"
// 	"sort"
// 	"strconv"
// 	"strings"
// 	"time"

// 	"github.com/gin-gonic/gin"
// 	"github.com/jmoiron/sqlx"
// 	"gorm.io/gorm"
// )

// // todo add struct
// type rangeMaterialCal struct {
// 	MaterialCode  string
// 	StartPlanDate time.Time
// 	EndPlanDate   time.Time
// }

// type UploadPlanRequest struct {
// 	StartCal           time.Time       `json:"start_cal"`
// 	IsBom              bool            `json:"is_bom"`
// 	IsCheckFg          bool            `json:"is_check_fg"`
// 	IsInitPlaned       bool            `json:"is_init_planed"`
// 	IsNotInitPlaned    bool            `json:"is_not_init_planed"`
// 	IsUrgentByStockDif bool            `json:"is_urgent_by_stock_dif"`
// 	MaterialStocks     []MaterialStock `json:"material_stocks"`
// 	RequestPlan        []RequestPlan   `json:"request_plan"`
// }

// type RequestPlan struct {
// 	MaterialCode     string     `json:"material_code"`
// 	LineCode         string     `json:"line_code"`
// 	RequestQty       float64    `json:"request_qty"`
// 	RequestPlantQty  float64    `json:"request_plant_qty"`
// 	RequestSubconQty float64    `json:"request_subcon_qty"`
// 	PlanDate         time.Time  `json:"plan_date"`
// 	EndPlanDate      *time.Time `json:"end_plan_date"`
// }

// type MaterialStock struct {
// 	MaterialCode   string  `json:"material_code"`
// 	StockPlantQty  float64 `json:"stock_plant_qty"`
// 	StockSubconQty float64 `json:"stock_subcon_qty"`
// }

// func ProcessingCalculateUploadPlan(c *gin.Context, jsonPayload string) (interface{}, error) {
// 	var req UploadPlanRequest

// 	if err := json.Unmarshal([]byte(jsonPayload), &req); err != nil {
// 		return nil, errors.New("failed to unmarshal JSON into struct: " + err.Error())
// 	}

// 	_, err := CalculateUploadPlan(req)
// 	if err != nil {
// 		return nil, err
// 	}

// 	return nil, nil
// }

// func CalculateUploadPlan(req UploadPlanRequest) (interface{}, error) {
// 	var reqPlan []RequestPlan
// 	var reqMatStock []MaterialStock
// 	reqPlan = req.RequestPlan
// 	reqMatStock = req.MaterialStocks

// 	gormx, err := db.ConnectGORM(`jit_portal`)
// 	if err != nil {
// 		return nil, err
// 	}
// 	defer db.CloseGORM(gormx)

// 	sqlx, err := db.ConnectSqlx(`jit_portal`)
// 	if err != nil {
// 		return nil, err
// 	}
// 	defer sqlx.Close()

// 	startDate := req.StartCal
// 	startDateStr := startDate.Format("2006-01-02")
// 	println((startDateStr))
// 	endDate := time.Now().Truncate(24 * time.Hour)

// 	isBom := req.IsBom
// 	isCheckFg := req.IsCheckFg
// 	matLineMap := map[string]map[string]MaterialLine{}
// 	var mats []Material
// 	matCheck := map[string]bool{}
// 	reqMap := map[string][]RequestPlan{}
// 	fgList := []string{}
// 	rageMatCalMap := map[string]rangeMaterialCal{} //todo add

// 	for i, item := range reqPlan {
// 		materialCode := item.MaterialCode
// 		lineCode := item.LineCode
// 		requestPlanQty := item.RequestPlantQty
// 		requestSubconQty := item.RequestSubconQty
// 		planDate := item.PlanDate.Truncate(24 * time.Hour)
// 		planDateStr := planDate.Format("2006-01-02")

// 		newReq := item
// 		newReq.RequestQty = requestPlanQty + requestSubconQty

// 		resKey := fmt.Sprintf(`%s|%s|%s`, planDateStr, materialCode, lineCode)
// 		reqMap[resKey] = append(reqMap[resKey], newReq)

// 		if i == 0 || endDate.Before(newReq.PlanDate) {
// 			endDate = newReq.PlanDate
// 		}

// 		materialKey := materialCode
// 		materialLineKey := fmt.Sprintf(`%s|%s`, materialCode, lineCode)
// 		if _, exist := matLineMap[materialKey]; !exist {
// 			matLineMap[materialKey] = map[string]MaterialLine{}
// 		}

// 		matLineMap[materialKey][materialLineKey] = MaterialLine{
// 			MaterialCode: materialCode,
// 			LineCode:     lineCode,
// 		}

// 		matKey := materialCode
// 		if _, exist := matCheck[matKey]; !exist {
// 			mats = append(mats, Material{
// 				MaterialCode: materialCode,
// 			})
// 			fgList = append(fgList, materialCode)

// 			matCheck[matKey] = true
// 		}

// 	}

// 	matBompMap, err := GetBom(sqlx, mats, isBom)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to get BOM: %w", err)
// 	}

// 	if isBom {
// 		rageMatCalMap = GetRangeMatCal(matBompMap, reqPlan)

// 		if err := ValidationBom(reqMap, matBompMap); err != nil {
// 			return nil, fmt.Errorf("failed to validation bom: %w", err)
// 		}
// 	}

// 	if isCheckFg {
// 		if err := ValidationFg(reqMap, matBompMap); err != nil {
// 			return nil, fmt.Errorf("failed to validation fg: %w", err)
// 		}
// 	}

// 	//todo adatedd&up
// 	var jitDailyPlan []JitDilyPlan
// 	var jitDailyMap map[string][]JitLine
// 	if req.IsNotInitPlaned {
// 		jitDailyPlan, jitDailyMap, err = BuildJitDailyByMaterial(rageMatCalMap, matLineMap, reqMap, matBompMap)
// 		if err != nil {
// 			return nil, fmt.Errorf("error building JIT daily map: %w", err)
// 		}
// 	} else {
// 		jitDailyPlan, jitDailyMap, err = BuildJitDaily(startDate, endDate, matLineMap, reqMap, matBompMap)
// 		if err != nil {
// 			return nil, fmt.Errorf("error building JIT daily map: %w", err)
// 		}
// 	}
// 	//

// 	if len(jitDailyPlan) == 0 || len(jitDailyMap) == 0 {
// 		return nil, fmt.Errorf("jitPlan or jitLine not found (%w)", err)
// 	}

// 	bomMats := []string{}
// 	bomMatCheck := map[string]bool{}
// 	for _, jitLines := range jitDailyMap {
// 		for _, item := range jitLines {
// 			materialCode := item.MaterialCode

// 			key := materialCode
// 			if _, exist := bomMatCheck[key]; !exist {
// 				bomMats = append(bomMats, materialCode)

// 				bomMatCheck[key] = true
// 			}
// 		}
// 	}

// 	jitDailyDBMap, err := GetJitDailyDB(sqlx, startDate, bomMats)
// 	if err != nil {
// 		return nil, fmt.Errorf("error get jit daily db: %w", err)
// 	}

// 	jitDailyMap, err = MergeJitDaily(startDate, jitDailyMap, jitDailyDBMap, req.IsNotInitPlaned)
// 	if err != nil {
// 		return nil, fmt.Errorf("error merge jit daily: %w", err)
// 	}

// 	jitMats, confirmMap, materialCodes, lineCodes, maxLineId, err := BuildToCalStruct(req.StartCal, jitDailyMap, reqMatStock)
// 	if err != nil {
// 		return nil, fmt.Errorf("error build cal struct: %w", err)
// 	}

// 	if req.IsUrgentByStockDif {
// 		lastEndStockMat, err := GetLastEndStockMaterial(sqlx, materialCodes, startDate)
// 		if err != nil {
// 			return nil, fmt.Errorf("error get last end stock: %w", err)
// 		}

// 		jitMats, err = CalculateUrgentStockDiff(jitMats, lastEndStockMat, startDate)
// 		if err != nil {
// 			return nil, fmt.Errorf("error cal urgent stock diff: %w", err)
// 		}
// 	}

// 	adjustLeadtimeMap := GetAdjustLeadtimeRequire(sqlx)

// 	fgMap, err := GetMatrialMap(sqlx, fgList)
// 	if err != nil {
// 		return nil, err
// 	}

// 	materialMap, err := GetMatrialMap(sqlx, materialCodes)
// 	if err != nil {
// 		return nil, err
// 	}

// 	jitMats, err = CalculateEstimate(jitMats, adjustLeadtimeMap, maxLineId, materialMap)
// 	if err != nil {
// 		return nil, fmt.Errorf("error calculate estimate: %w", err)
// 	}

// 	jitMats, err = CalculateActual(jitMats, confirmMap)
// 	if err != nil {
// 		return nil, fmt.Errorf("error calculate actual: %w", err)
// 	}

// 	lineMap, err := GetLineMap(sqlx, lineCodes)
// 	if err != nil {
// 		return nil, err
// 	}

// 	jitDailys, err := ConvertToJitDailyDB(jitMats, lineMap, materialMap)
// 	if err != nil {
// 		return nil, fmt.Errorf("error convert jit daily db: %w", err)
// 	}

// 	jitProcesses, err := ConvertToProcessDB(jitDailyPlan, lineMap, fgMap)
// 	if err != nil {
// 		return nil, fmt.Errorf("error convert jit plan db: %w", err)
// 	}

// 	err = CreateJitDaily(gormx, sqlx, jitProcesses, jitDailys, startDate)
// 	if err != nil {
// 		return nil, fmt.Errorf("error create jit daily: %w", err)
// 	}

// 	return nil, nil
// }

// func GetStartDate(sqlx *sqlx.DB) time.Time {
// 	result, err := db.ExecuteQuery(sqlx, "select start_cal_date_kr() date")

// 	if err != nil {
// 		return time.Now()
// 	}

// 	return result[0]["date"].(time.Time)
// }

// func GetRangeMatCal(bomMats map[string]Material, reqPlan []RequestPlan) map[string]rangeMaterialCal {
// 	rageMatCalMap := map[string]rangeMaterialCal{}

// 	for _, reqData := range reqPlan {

// 		bom, existsBom := bomMats[reqData.MaterialCode]

// 		if existsBom {
// 			for _, bomData := range bom.Boms {
// 				materialCode := bomData.MaterialCode
// 				planDate := reqData.PlanDate.Truncate(24 * time.Hour)

// 				rangeKey := materialCode
// 				rageMatCal, exist := rageMatCalMap[rangeKey]
// 				if !exist {
// 					newRageMatCal := rangeMaterialCal{
// 						MaterialCode:  materialCode,
// 						StartPlanDate: planDate,
// 						EndPlanDate:   planDate,
// 					}

// 					rageMatCalMap[rangeKey] = newRageMatCal
// 					rageMatCal = newRageMatCal
// 				}

// 				if rageMatCal.StartPlanDate.After(planDate) {
// 					rageMatCal.StartPlanDate = planDate
// 				}

// 				if rageMatCal.EndPlanDate.Before(planDate) {
// 					rageMatCal.EndPlanDate = planDate
// 				}

// 				rageMatCalMap[rangeKey] = rageMatCal
// 			}
// 		}
// 	}

// 	return rageMatCalMap
// }

// func GetBom(sqlx *sqlx.DB, mats []Material, isBom bool) (map[string]Material, error) {
// 	matMap := map[string]Material{}

// 	var matStr []string
// 	matStrCheck := map[string]bool{}

// 	for _, item := range mats {
// 		key := item.MaterialCode

// 		if _, exist := matStrCheck[key]; !exist {
// 			matStr = append(matStr, item.MaterialCode)

// 			matStrCheck[key] = true
// 		}
// 	}

// 	if len(matStr) == 0 {
// 		return nil, fmt.Errorf(`not found material`)
// 	}

// 	query := fmt.Sprintf(`
// 		select m.material_id as material_id, m.material_code as material_code
// 			, m.supplier_id as supplier_id, coalesce(m.delivery_lead_time,0) as material_lead_time
// 			, coalesce(s.supplier_code, '') as supplier_code
// 			, coalesce(jm.fb_material_id, 0) as bom_id, coalesce(jm.fg_per_fb,0) as bom_qty, coalesce(jm.waste,0) as bom_waste
// 			, coalesce(mb.material_code, '') as bom_code,  coalesce(mb.delivery_lead_time,0) as bom_lead_time
// 		from materials m
// 		left join jit_master jm on m.material_id  = jm.fg_material_id
// 		left join suppliers s on m.supplier_id = s.supplier_id
// 		left join materials mb on mb.material_id = jm.fb_material_id
// 		where 1=1
// 		and m.material_code in ('%s')
// 	`, strings.Join(matStr, `','`))
// 	// and m.inventory_mode = 3 and coalesce(jm.type, 1) = 1
// 	//println(query)
// 	rows, err := db.ExecuteQuery(sqlx, query)
// 	if err != nil {
// 		return nil, err
// 	}

// 	for _, item := range rows {
// 		materialId := item["material_id"].(int64)
// 		materialCode := item["material_code"].(string)
// 		supplierId := item["supplier_id"].(int64)
// 		supplierCode := item["supplier_code"].(string)
// 		bomId := item["bom_id"].(int64)
// 		bomCode := item["bom_code"].(string)
// 		bomQty := item["bom_qty"].(float64)
// 		materialLeadTime := int64(item["material_lead_time"].(float64))
// 		bomLeadTime := int64(item["bom_lead_time"].(float64))
// 		bomWaste := item["bom_waste"].(float64)

// 		key := materialCode

// 		mat, exist := matMap[key]
// 		if !exist {
// 			mat = Material{
// 				MaterialId:   materialId,
// 				MaterialCode: materialCode,
// 				SupplierId:   supplierId,
// 				SupplierCode: supplierCode,
// 				Qty:          1,
// 				LeadTime:     materialLeadTime,
// 			}
// 		}

// 		if bomId != 0 && isBom {
// 			mat.Boms = append(mat.Boms, Bom{
// 				MaterialId:   bomId,
// 				MaterialCode: bomCode,
// 				LeadTime:     bomLeadTime,
// 				Qty:          bomQty,
// 				Waste:        bomWaste,
// 			})
// 		}

// 		matMap[key] = mat
// 	}

// 	return matMap, nil
// }

// func ValidationBom(planMap map[string][]RequestPlan, matBompMap map[string]Material) error {
// 	for _, plan := range planMap {
// 		for _, item := range plan {
// 			materialCode := item.MaterialCode

// 			matBom, exist := matBompMap[materialCode]
// 			if !exist || len(matBom.Boms) == 0 {
// 				return fmt.Errorf(`not found bom of material code : %s`, materialCode)
// 			}
// 		}
// 	}

// 	return nil
// }

// func ValidationFg(planMap map[string][]RequestPlan, matBompMap map[string]Material) error {
// 	for _, plan := range planMap {
// 		for _, item := range plan {
// 			materialCode := item.MaterialCode

// 			if _, exist := matBompMap[materialCode]; !exist {
// 				return fmt.Errorf(`not found bom of material code : %s`, materialCode)
// 			}
// 		}
// 	}

// 	return nil
// }

// // todo add
// func BuildJitDailyByMaterial(rageMatCalMap map[string]rangeMaterialCal, matLineMap map[string]map[string]MaterialLine, datas map[string][]RequestPlan, matBomMap map[string]Material) ([]JitDilyPlan, map[string][]JitLine, error) {
// 	jitLineMap := map[string][]JitLine{}
// 	JitDilyPlans := []JitDilyPlan{}
// 	planIdCount := int64(1)

// 	for matKey, mat := range matLineMap {
// 		fgCode := matKey
// 		matBomKey := fgCode
// 		matBom, matBomExist := matBomMap[matBomKey]
// 		if !matBomExist {
// 			continue
// 		}

// 		for _, bom := range matBom.Boms {
// 			materialCode := bom.MaterialCode
// 			rageMatCalKey := bom.MaterialCode
// 			rageMatCal, rageMatCalExist := rageMatCalMap[rageMatCalKey]

// 			if !rageMatCalExist {
// 				return nil, nil, fmt.Errorf(`not found rageMatCal of material code : %s`, materialCode)
// 			}

// 			startPlanDate := rageMatCal.StartPlanDate
// 			endPlanDate := rageMatCal.EndPlanDate

// 			for currentDate := startPlanDate; !currentDate.After(endPlanDate); currentDate = currentDate.Add(24 * time.Hour) {
// 				for _, matLine := range mat {
// 					planDateStr := currentDate.Format("2006-01-02")

// 					materialCode := matLine.MaterialCode
// 					lineCode := matLine.LineCode
// 					jitLineKey := fmt.Sprintf(`%s|%s|%s`, planDateStr, materialCode, lineCode)

// 					dataItems, dataItemExists := datas[jitLineKey]
// 					if dataItemExists {
// 						for _, dataItem := range dataItems {
// 							planId := planIdCount
// 							materialCode := dataItem.MaterialCode
// 							lineCode := dataItem.LineCode
// 							requestQty := dataItem.RequestQty
// 							requestPlanQty := dataItem.RequestPlantQty
// 							requestSubconQty := dataItem.RequestSubconQty
// 							planDate := dataItem.PlanDate
// 							endPlandate := dataItem.EndPlanDate

// 							JitDilyPlans = append(JitDilyPlans, JitDilyPlan{
// 								PlanId:           planId,
// 								MaterialCode:     materialCode,
// 								LineCode:         lineCode,
// 								RequestQty:       requestQty,
// 								RequestPlantQty:  requestPlanQty,
// 								RequestSubconQty: requestSubconQty,
// 								PlanDate:         planDate,
// 								EndPlanDate:      endPlandate,
// 							})

// 							if len(matBom.Boms) > 0 {
// 								for _, bom := range matBom.Boms {
// 									bomMaterialCode := bom.MaterialCode
// 									waste := bom.Waste
// 									bomLeadTime := bom.LeadTime

// 									jitLineBomKey := fmt.Sprintf(`%s|%s|%s`, planDateStr, bomMaterialCode, lineCode)

// 									jitLine := JitLine{
// 										id:                  0,
// 										PlanId:              &planId,
// 										DailyDate:           currentDate,
// 										MaterialCode:        bomMaterialCode,
// 										LineCode:            lineCode,
// 										ProductionQty:       requestQty,
// 										ProductionPlantQty:  requestPlanQty,
// 										ProductionSubconQty: requestSubconQty,
// 										RequireQty:          0,
// 										UrgenQty:            0,
// 										LeadTime:            bomLeadTime,
// 										RefReuqestID:        nil,
// 									}

// 									if jitLine.ProductionQty == 0 || bom.Qty == 0 {
// 										return nil, nil, fmt.Errorf(`productionQty or bom.qty = 0`)
// 									}

// 									//waste
// 									ProductionQty := (jitLine.ProductionQty / bom.Qty)
// 									if waste != 0 {
// 										ProductionQty *= (1 + waste/100)
// 									}

// 									jitLine.ProductionQty = ProductionQty
// 									jitLineMap[jitLineBomKey] = append(jitLineMap[jitLineBomKey], jitLine)
// 								}
// 							} else {
// 								materialLeadTime := matBom.LeadTime

// 								jitLine := JitLine{
// 									id:                  0,
// 									PlanId:              &planId,
// 									DailyDate:           currentDate,
// 									MaterialCode:        materialCode,
// 									LineCode:            lineCode,
// 									ProductionQty:       requestQty,
// 									ProductionPlantQty:  requestPlanQty,
// 									ProductionSubconQty: requestSubconQty,
// 									RequireQty:          0,
// 									UrgenQty:            0,
// 									LeadTime:            materialLeadTime,
// 									RefReuqestID:        nil,
// 								}

// 								jitLineMap[jitLineKey] = append(jitLineMap[jitLineKey], jitLine)
// 							}

// 							planIdCount++
// 						}
// 					} else {
// 						if len(matBom.Boms) > 0 {
// 							for _, bom := range matBom.Boms {
// 								bomMaterialCode := bom.MaterialCode
// 								jitLineBomKey := fmt.Sprintf(`%s|%s|%s`, planDateStr, bomMaterialCode, lineCode)

// 								jitLine := JitLine{
// 									id:                  0,
// 									DailyDate:           currentDate,
// 									MaterialCode:        bomMaterialCode,
// 									LineCode:            lineCode,
// 									ProductionQty:       0,
// 									ProductionPlantQty:  0,
// 									ProductionSubconQty: 0,
// 									RequireQty:          0,
// 									UrgenQty:            0,
// 									LeadTime:            bom.LeadTime,
// 									RefReuqestID:        nil,
// 								}

// 								jitLineMap[jitLineBomKey] = append(jitLineMap[jitLineBomKey], jitLine)
// 							}
// 						} else {
// 							materialLeadTime := matBom.LeadTime

// 							jitLine := JitLine{
// 								id:                  0,
// 								DailyDate:           currentDate,
// 								MaterialCode:        materialCode,
// 								LineCode:            lineCode,
// 								ProductionQty:       0,
// 								ProductionPlantQty:  0,
// 								ProductionSubconQty: 0,
// 								RequireQty:          0,
// 								UrgenQty:            0,
// 								LeadTime:            materialLeadTime,
// 								RefReuqestID:        nil,
// 							}

// 							jitLineMap[jitLineKey] = append(jitLineMap[jitLineKey], jitLine)
// 						}
// 					}
// 				}
// 			}

// 		}
// 	}

// 	return JitDilyPlans, jitLineMap, nil
// }

// func BuildJitDaily(startDate time.Time, endDate time.Time, matLineMap map[string]map[string]MaterialLine, datas map[string][]RequestPlan, matBomMap map[string]Material) ([]JitDilyPlan, map[string][]JitLine, error) {
// 	jitLineMap := map[string][]JitLine{}
// 	JitDilyPlans := []JitDilyPlan{}
// 	planIdCount := int64(1)

// 	for currentDate := startDate; !currentDate.After(endDate); currentDate = currentDate.Add(24 * time.Hour) {
// 		for _, mat := range matLineMap {

// 			for _, matLine := range mat {
// 				planDateStr := currentDate.Format("2006-01-02")

// 				materialCode := matLine.MaterialCode
// 				lineCode := matLine.LineCode
// 				jitLineKey := fmt.Sprintf(`%s|%s|%s`, planDateStr, materialCode, lineCode)

// 				matBomKey := materialCode
// 				matBom, matBomExist := matBomMap[matBomKey]
// 				if !matBomExist {
// 					continue
// 				}

// 				dataItems, dataItemExists := datas[jitLineKey]
// 				if dataItemExists {
// 					for _, dataItem := range dataItems {
// 						planId := planIdCount
// 						materialCode := dataItem.MaterialCode
// 						lineCode := dataItem.LineCode
// 						requestQty := dataItem.RequestQty
// 						requestPlanQty := dataItem.RequestPlantQty
// 						requestSubconQty := dataItem.RequestSubconQty
// 						planDate := dataItem.PlanDate
// 						endPlandate := dataItem.EndPlanDate

// 						JitDilyPlans = append(JitDilyPlans, JitDilyPlan{
// 							PlanId:           planId,
// 							MaterialCode:     materialCode,
// 							LineCode:         lineCode,
// 							RequestQty:       requestQty,
// 							RequestPlantQty:  requestPlanQty,
// 							RequestSubconQty: requestSubconQty,
// 							PlanDate:         planDate,
// 							EndPlanDate:      endPlandate,
// 						})

// 						if len(matBom.Boms) > 0 {
// 							for _, bom := range matBom.Boms {
// 								bomMaterialCode := bom.MaterialCode
// 								waste := bom.Waste
// 								bomLeadTime := bom.LeadTime

// 								jitLineBomKey := fmt.Sprintf(`%s|%s|%s`, planDateStr, bomMaterialCode, lineCode)

// 								jitLine := JitLine{
// 									id:                  0,
// 									PlanId:              &planId,
// 									DailyDate:           currentDate,
// 									MaterialCode:        bomMaterialCode,
// 									LineCode:            lineCode,
// 									ProductionQty:       requestQty,
// 									ProductionPlantQty:  requestPlanQty,
// 									ProductionSubconQty: requestSubconQty,
// 									RequireQty:          0,
// 									UrgenQty:            0,
// 									LeadTime:            bomLeadTime,
// 									RefReuqestID:        nil,
// 								}

// 								// if jitLine.ProductionQty == 0 || bom.Qty == 0 {
// 								// 	return nil, nil, fmt.Errorf(`productionQty or bom.qty = 0`)
// 								// }

// 								if !(jitLine.ProductionQty == 0 || bom.Qty == 0) {
// 									ProductionQty := (jitLine.ProductionQty / bom.Qty)
// 									if waste != 0 {
// 										ProductionQty *= (1 + waste/100)
// 									}

// 									jitLine.ProductionQty = ProductionQty
// 								}

// 								jitLineMap[jitLineBomKey] = append(jitLineMap[jitLineBomKey], jitLine)
// 							}
// 						} else {
// 							materialLeadTime := matBom.LeadTime

// 							jitLine := JitLine{
// 								id:                  0,
// 								PlanId:              &planId,
// 								DailyDate:           currentDate,
// 								MaterialCode:        materialCode,
// 								LineCode:            lineCode,
// 								ProductionQty:       requestQty,
// 								ProductionPlantQty:  requestPlanQty,
// 								ProductionSubconQty: requestSubconQty,
// 								RequireQty:          0,
// 								UrgenQty:            0,
// 								LeadTime:            materialLeadTime,
// 								RefReuqestID:        nil,
// 							}

// 							jitLineMap[jitLineKey] = append(jitLineMap[jitLineKey], jitLine)
// 						}

// 						planIdCount++
// 					}
// 				} else {
// 					if len(matBom.Boms) > 0 {
// 						for _, bom := range matBom.Boms {
// 							bomMaterialCode := bom.MaterialCode
// 							jitLineBomKey := fmt.Sprintf(`%s|%s|%s`, planDateStr, bomMaterialCode, lineCode)

// 							jitLine := JitLine{
// 								id:                  0,
// 								DailyDate:           currentDate,
// 								MaterialCode:        bomMaterialCode,
// 								LineCode:            lineCode,
// 								ProductionQty:       0,
// 								ProductionPlantQty:  0,
// 								ProductionSubconQty: 0,
// 								RequireQty:          0,
// 								UrgenQty:            0,
// 								LeadTime:            bom.LeadTime,
// 								RefReuqestID:        nil,
// 							}

// 							jitLineMap[jitLineBomKey] = append(jitLineMap[jitLineBomKey], jitLine)
// 						}
// 					} else {
// 						materialLeadTime := matBom.LeadTime

// 						jitLine := JitLine{
// 							id:                  0,
// 							DailyDate:           currentDate,
// 							MaterialCode:        materialCode,
// 							LineCode:            lineCode,
// 							ProductionQty:       0,
// 							ProductionPlantQty:  0,
// 							ProductionSubconQty: 0,
// 							RequireQty:          0,
// 							UrgenQty:            0,
// 							LeadTime:            materialLeadTime,
// 							RefReuqestID:        nil,
// 						}

// 						jitLineMap[jitLineKey] = append(jitLineMap[jitLineKey], jitLine)
// 					}
// 				}
// 			}
// 		}
// 	}

// 	return JitDilyPlans, jitLineMap, nil
// }

// func GetJitDailyDB(sqlx *sqlx.DB, startDate time.Time, matStrs []string) (map[string][]JitLine, error) {
// 	jitDailyMap := map[string][]JitLine{}

// 	startCalDate := startDate.Format("2006-01-02")

// 	query := fmt.Sprintf(`
// 		select jd.jit_daily_id as id
// 			, jd.jit_daily_plan_id  as plan_id
// 			, jd.original_jit_daily_id as ref_request_id
// 			, jd.daily_date
// 			, coalesce(jd.product_qty, 0) as production_qty
// 			, coalesce(jd.plant_qty , 0) as production_plant_qty
// 			, coalesce(jd.subcon_qty , 0) as production_subcon_qty
// 			, coalesce(jd.required_qty, 0)  as require_qty
// 			, coalesce(jd.urgent_qty, 0) as urgent_qty
// 			, coalesce(jd.conf_qty ,0) as confirm_require_qty
// 			, coalesce(jd.conf_urgent_qty ,0) as confirm_urgent_qty
// 			, jd.conf_date as confirm_require_date
// 			, jd.conf_urgent_date as confirm_urgent_date
// 			, m.material_code
// 			, coalesce(jlh.line_header_name,'') as line_code
// 			, coalesce(m.delivery_lead_time,0) as delivery_lead_time
// 		from jit_daily jd
// 		left join materials m on jd.material_id = m.material_id
// 		left join jit_line_headers jlh on jlh.line_header_id = jd.line_id
// 		where 1=1
// 		and jd.is_deleted = false
// 		and (jd.daily_date >= '%s' or jd.conf_date >= '%s' or jd.conf_urgent_date >= '%s')
// 		and m.material_code in ('%s')
// 	`, startCalDate, startCalDate, startCalDate, strings.Join(matStrs, `','`))
// 	println(query)
// 	rows, err := db.ExecuteQuery(sqlx, query)
// 	if err != nil {
// 		return nil, err
// 	}

// 	for _, item := range rows {
// 		id := item["id"].(int64)
// 		planDate := item["daily_date"].(time.Time).Truncate(24 * time.Hour)
// 		planDateStr := planDate.Format("2006-01-02")
// 		materialCode := item["material_code"].(string)
// 		lineCode := item["line_code"].(string)
// 		productionQty := item["production_qty"].(float64)
// 		productionPlantQty := item["production_plant_qty"].(float64)
// 		productionSubconQty := item["production_subcon_qty"].(float64)
// 		requireQty := item["require_qty"].(float64)
// 		urgentQty := item["urgent_qty"].(float64)
// 		confirmRequireQty := item["confirm_require_qty"].(float64)
// 		confirmUrgentQty := item["confirm_urgent_qty"].(float64)
// 		leadTime := int64(item["delivery_lead_time"].(float64))
// 		var refRequestId *int64
// 		var confirmRequireDate *time.Time
// 		var confirmUrgentDate *time.Time
// 		var planId *int64

// 		if val, ok := item["confirm_require_date"]; ok && val != nil {
// 			if v, ok := val.(time.Time); ok {
// 				confirmRequireDate = &v
// 			}
// 		}

// 		if val, ok := item["confirm_urgent_date"]; ok && val != nil {
// 			if v, ok := val.(time.Time); ok {
// 				confirmRequireDate = &v
// 			}
// 		}

// 		if val, ok := item["ref_request_id"]; ok && val != nil {
// 			if v, ok := val.(int64); ok {
// 				refRequestId = &v
// 			}
// 		}

// 		if val, ok := item["plan_id"]; ok && val != nil {
// 			if v, ok := val.(int64); ok {
// 				planId = &v
// 			}
// 		}

// 		jitDailyKey := fmt.Sprintf(`%s|%s|%s`, planDateStr, materialCode, lineCode)

// 		newJit := JitLine{
// 			id:                  id,
// 			PlanId:              planId,
// 			DailyDate:           planDate,
// 			MaterialCode:        materialCode,
// 			LineCode:            lineCode,
// 			ProductionQty:       productionQty,
// 			ProductionPlantQty:  productionPlantQty,
// 			ProductionSubconQty: productionSubconQty,
// 			RequireQty:          requireQty,
// 			UrgenQty:            urgentQty,
// 			ConfirmRequireQty:   confirmRequireQty,
// 			ConfirmUrgentQty:    confirmUrgentQty,
// 			ConfirmRequireDate:  confirmRequireDate,
// 			ConfirmUrgentDate:   confirmUrgentDate,
// 			LeadTime:            leadTime,
// 			RefReuqestID:        refRequestId,
// 		}

// 		jitDailyMap[jitDailyKey] = append(jitDailyMap[jitDailyKey], newJit)
// 	}

// 	return jitDailyMap, nil
// }

// func MergeJitDaily(startDate time.Time, jitLineMap map[string][]JitLine, jitLineDBMap map[string][]JitLine, isNotInitPlaned bool) (map[string][]JitLine, error) {
// 	ignoreWeeks := map[string]map[int]bool{}
// 	jitMatDate := map[string]bool{}

// 	for jitLineKey, jitLines := range jitLineMap {
// 		for jitLineDBKey, jitLineDB := range jitLineDBMap {
// 			if jitLineKey == jitLineDBKey {
// 				sumConfirmRequireQty := 0.0
// 				sumConfirmUrgentQty := 0.0
// 				var maxConfirmRequireDate *time.Time
// 				var maxConfirmUrgentDate *time.Time

// 				for _, jitLineDB := range jitLineDB {
// 					if jitLineDB.ConfirmRequireDate != nil {
// 						if maxConfirmRequireDate == nil || maxConfirmRequireDate.Before(*jitLineDB.ConfirmRequireDate) {
// 							maxConfirmRequireDate = jitLineDB.ConfirmRequireDate
// 						}
// 					}

// 					if jitLineDB.ConfirmUrgentDate != nil {
// 						if maxConfirmUrgentDate == nil || maxConfirmUrgentDate.Before(*jitLineDB.ConfirmUrgentDate) {
// 							maxConfirmUrgentDate = jitLineDB.ConfirmUrgentDate
// 						}
// 					}

// 					sumConfirmRequireQty += jitLineDB.ConfirmRequireQty
// 					sumConfirmUrgentQty += jitLineDB.ConfirmUrgentQty
// 				}

// 				for i, jitLine := range jitLines {
// 					if i+1 == len(jitLines) {
// 						jitLineMap[jitLineKey][i].ConfirmRequireQty += sumConfirmRequireQty
// 						jitLineMap[jitLineKey][i].ConfirmUrgentQty += sumConfirmUrgentQty

// 						if maxConfirmRequireDate != nil && (jitLine.ConfirmRequireDate == nil || jitLine.ConfirmRequireDate.Before(*maxConfirmRequireDate)) {
// 							jitLineMap[jitLineKey][i].ConfirmRequireDate = maxConfirmRequireDate
// 						}

// 						if maxConfirmUrgentDate != nil && (jitLine.ConfirmUrgentDate == nil || jitLine.ConfirmUrgentDate.Before(*maxConfirmUrgentDate)) {
// 							jitLineMap[jitLineKey][i].ConfirmUrgentDate = maxConfirmUrgentDate
// 						}
// 					}
// 				}
// 			}
// 		}

// 		for _, jitLine := range jitLines {
// 			materialCode := jitLine.MaterialCode
// 			planDate := jitLine.DailyDate
// 			planDateStr := planDate.Truncate(24 * time.Hour).Format(`2006-01-02`)

// 			matKey := materialCode
// 			_, week := planDate.ISOWeek()
// 			weekKey := week
// 			if _, exists := ignoreWeeks[matKey]; !exists {
// 				ignoreWeeks[matKey] = make(map[int]bool)
// 				ignoreWeeks[matKey][weekKey] = true
// 			} else {
// 				ignoreWeeks[matKey][weekKey] = true
// 			}

// 			// if _, exist := ignoreWeeks[weekKey]; !exist {
// 			// 	ignoreWeeks[weekKey] = true
// 			// }

// 			jitMatDateKey := fmt.Sprintf(`%s|%s`, materialCode, planDateStr)
// 			if _, exist := jitMatDate[jitMatDateKey]; !exist && jitLine.ProductionQty > 0 {
// 				jitMatDate[jitMatDateKey] = true
// 			}
// 		}
// 	}

// 	for jitLineDBKey, jitLineDBs := range jitLineDBMap {
// 		for _, jitLineDB := range jitLineDBs {
// 			dbMaterialCode := jitLineDB.MaterialCode
// 			dbPlanDate := jitLineDB.DailyDate
// 			dbPlanDateStr := dbPlanDate.Truncate(24 * time.Hour).Format(`2006-01-02`)
// 			productionQty := 0.0
// 			productionPlantQty := 0.0
// 			productionSubconQty := 0.0
// 			var planId *int64

// 			jitMatDateKey := fmt.Sprintf(`%s|%s`, dbMaterialCode, dbPlanDateStr)
// 			_, jitMatDateExist := jitMatDate[jitMatDateKey]

// 			if !jitMatDateExist && isNotInitPlaned {
// 				matKey := dbMaterialCode

// 				_, week := jitLineDB.DailyDate.ISOWeek()
// 				weekKey := week
// 				_, ignoreWeekExist := ignoreWeeks[matKey][weekKey]

// 				if !ignoreWeekExist {
// 					productionQty = jitLineDB.ProductionQty
// 					productionPlantQty = jitLineDB.ProductionPlantQty
// 					productionSubconQty = jitLineDB.ProductionSubconQty
// 				}
// 			}

// 			if productionQty > 0 {
// 				planId = jitLineDB.PlanId
// 			}

// 			newJit := JitLine{
// 				id:                  0,
// 				PlanId:              planId,
// 				DailyDate:           jitLineDB.DailyDate,
// 				MaterialCode:        jitLineDB.MaterialCode,
// 				LineCode:            jitLineDB.LineCode,
// 				ProductionQty:       productionQty,
// 				ProductionPlantQty:  productionPlantQty,
// 				ProductionSubconQty: productionSubconQty,
// 				RequireQty:          0,
// 				UrgenQty:            0,
// 				ConfirmRequireQty:   jitLineDB.ConfirmRequireQty,
// 				ConfirmUrgentQty:    jitLineDB.ConfirmUrgentQty,
// 				ConfirmRequireDate:  jitLineDB.ConfirmRequireDate,
// 				ConfirmUrgentDate:   jitLineDB.ConfirmUrgentDate,
// 				LeadTime:            jitLineDB.LeadTime,
// 				RefReuqestID:        nil,
// 			}

// 			jitLineMap[jitLineDBKey] = append(jitLineMap[jitLineDBKey], newJit)
// 		}
// 	}

// 	rowsIdCount := int64(1)
// 	for _, jitLines := range jitLineMap {
// 		for i := range jitLines {
// 			jitLines[i].id = rowsIdCount
// 			rowsIdCount++
// 		}
// 	}

// 	return jitLineMap, nil
// }

// func BuildToCalStruct(startCal time.Time, jitLineMap map[string][]JitLine, matStock []MaterialStock) ([]JitMaterial, map[string][]JitDate, []string, []string, int64, error) {
// 	jitMats := []JitMaterial{}
// 	matStockMap := map[string]MaterialStock{}
// 	confirmJitDateMap := map[string][]JitDate{}
// 	lineCodes := []string{}
// 	checkLineCodeMap := map[string]bool{}
// 	materialCodes := []string{}
// 	checkMaterialCodeMap := map[string]bool{}
// 	maxId := int64(0)

// 	//map stock
// 	for _, item := range matStock {
// 		materialCode := item.MaterialCode
// 		key := materialCode
// 		matStockMap[key] = item
// 	}

// 	//convert and prepare data
// 	for _, jitLines := range jitLineMap {
// 		for _, jd := range jitLines {
// 			materialCode := jd.MaterialCode
// 			planDate := jd.DailyDate
// 			planDateTrucn := planDate.Truncate(24 * time.Hour)
// 			id := jd.id
// 			refReqId := jd.RefReuqestID
// 			planId := jd.PlanId
// 			lineCode := jd.LineCode
// 			productQty := jd.ProductionQty
// 			productPlantQty := jd.ProductionPlantQty
// 			productSubconQty := jd.ProductionSubconQty
// 			requireQty := jd.RequireQty
// 			urgentQty := jd.UrgenQty
// 			confirmRequireQty := jd.ConfirmRequireQty
// 			confirmRequireDate := jd.ConfirmRequireDate
// 			confirmUrgentQty := jd.ConfirmUrgentQty
// 			confirmUrgentDate := jd.ConfirmUrgentDate
// 			leadTime := jd.LeadTime

// 			if id > maxId {
// 				maxId = id
// 			}

// 			lineCodeKey := lineCode
// 			if _, exist := checkLineCodeMap[lineCodeKey]; !exist {
// 				lineCodes = append(lineCodes, lineCode)
// 				checkLineCodeMap[lineCodeKey] = true
// 			}

// 			materialCodeKey := materialCode
// 			if _, exist := checkMaterialCodeMap[materialCodeKey]; !exist {
// 				materialCodes = append(materialCodes, materialCode)
// 				checkMaterialCodeMap[materialCodeKey] = true
// 			}

// 			matStock, exist := matStockMap[materialCode]
// 			if !exist {
// 				matStock = MaterialStock{}
// 			}

// 			newJitLine := JitLine{
// 				id:                  id,
// 				PlanId:              planId,
// 				RefReuqestID:        refReqId,
// 				MaterialCode:        materialCode,
// 				DailyDate:           planDate,
// 				LineCode:            lineCode,
// 				ProductionQty:       productQty,
// 				ProductionPlantQty:  productPlantQty,
// 				ProductionSubconQty: productSubconQty,
// 				RequireQty:          requireQty,
// 				UrgenQty:            urgentQty,
// 				ConfirmRequireQty:   confirmRequireQty,
// 				ConfirmUrgentQty:    confirmUrgentQty,
// 				ConfirmRequireDate:  confirmRequireDate,
// 				ConfirmUrgentDate:   confirmUrgentDate,
// 				LeadTime:            leadTime,
// 			}

// 			newJitDate := JitDate{
// 				Date:               planDateTrucn,
// 				ProductionQty:      productQty,
// 				RequireQty:         requireQty,
// 				UrgentQty:          urgentQty,
// 				ConfirmQty:         confirmRequireQty + confirmUrgentQty,
// 				ConfirmRequireQty:  confirmRequireQty,
// 				ConfirmUrgentQty:   confirmUrgentQty,
// 				ConfirmRequireDate: confirmRequireDate,
// 				ConfirmUrgentDate:  confirmUrgentDate,
// 				Lines:              []JitLine{newJitLine},
// 			}

// 			newJitMat := JitMaterial{
// 				MaterialCode: materialCode,
// 				Stock:        matStock,
// 				LeadTime:     leadTime,
// 				JitDates:     []JitDate{newJitDate},
// 			}

// 			if confirmRequireDate != nil || confirmUrgentDate != nil {
// 				if confirmRequireDate != nil {
// 					key := fmt.Sprintf("%s|%s|%s", materialCode, confirmRequireDate.Format("2006-01-02"), "R")
// 					confirmJitDateMap[key] = append(confirmJitDateMap[key], newJitDate)
// 				}

// 				if confirmUrgentDate != nil {
// 					key := fmt.Sprintf("%s|%s|%s", materialCode, confirmUrgentDate.Format("2006-01-02"), "U")
// 					confirmJitDateMap[key] = append(confirmJitDateMap[key], newJitDate)
// 				}
// 			}

// 			if planDate.Before(startCal) {
// 				continue
// 			}

// 			isFoundMat := false
// 			for cJitMat, jitMat := range jitMats {
// 				if jitMat.MaterialCode == materialCode {
// 					isFoundDate := false

// 					for cJitDate, jitDate := range jitMat.JitDates {
// 						if jitDate.Date.Equal(planDate) {
// 							jitMats[cJitMat].JitDates[cJitDate].ProductionQty += productQty
// 							jitMats[cJitMat].JitDates[cJitDate].RequireQty += requireQty
// 							jitMats[cJitMat].JitDates[cJitDate].UrgentQty += urgentQty
// 							jitMats[cJitMat].JitDates[cJitDate].ConfirmQty += confirmRequireQty + confirmUrgentQty
// 							jitMats[cJitMat].JitDates[cJitDate].ConfirmRequireQty += confirmRequireQty
// 							jitMats[cJitMat].JitDates[cJitDate].ConfirmUrgentQty += confirmUrgentQty

// 							if confirmRequireDate != nil {
// 								if jitMats[cJitMat].JitDates[cJitDate].ConfirmRequireDate == nil || jitMats[cJitMat].JitDates[cJitDate].ConfirmRequireDate.After(*confirmRequireDate) {
// 									jitMats[cJitMat].JitDates[cJitDate].ConfirmRequireDate = confirmRequireDate
// 								}
// 							}

// 							if confirmUrgentDate != nil {
// 								if jitMats[cJitMat].JitDates[cJitDate].ConfirmUrgentDate == nil || jitMats[cJitMat].JitDates[cJitDate].ConfirmUrgentDate.After(*confirmUrgentDate) {
// 									jitMats[cJitMat].JitDates[cJitDate].ConfirmUrgentDate = confirmUrgentDate
// 								}
// 							}

// 							jitMats[cJitMat].JitDates[cJitDate].Lines = append(jitMats[cJitMat].JitDates[cJitDate].Lines, newJitLine)

// 							isFoundDate = true
// 							break
// 						}
// 					}

// 					if !isFoundDate {
// 						jitMats[cJitMat].JitDates = append(jitMats[cJitMat].JitDates, newJitDate)
// 					}

// 					isFoundMat = true
// 					break
// 				}
// 			}

// 			if !isFoundMat {
// 				jitMats = append(jitMats, newJitMat)
// 			}
// 		}
// 	}

// 	//Sort data by Date, Line
// 	for i := range jitMats {
// 		sort.Slice(jitMats[i].JitDates, func(a, b int) bool {
// 			return jitMats[i].JitDates[a].Date.Before(jitMats[i].JitDates[b].Date)
// 		})

// 		for j := range jitMats[i].JitDates {
// 			sort.Slice(jitMats[i].JitDates[j].Lines, func(a, b int) bool {
// 				if jitMats[i].JitDates[j].Lines[a].DailyDate.Equal(jitMats[i].JitDates[j].Lines[b].DailyDate) {
// 					return jitMats[i].JitDates[j].Lines[a].LineCode < jitMats[i].JitDates[j].Lines[b].LineCode
// 				}
// 				return jitMats[i].JitDates[j].Lines[a].DailyDate.Before(jitMats[i].JitDates[j].Lines[b].DailyDate)
// 			})
// 		}
// 	}

// 	return jitMats, confirmJitDateMap, materialCodes, lineCodes, maxId, nil
// }

// func GetLastEndStockMaterial(sqlx *sqlx.DB, materialCodes []string, startCalDate time.Time) (map[string]Material, error) {
// 	lastStockMat := map[string]Material{}

// 	query := `
// 		select
// 			coalesce(jd.daily_date, '1990-01-01') daily_date,
// 			coalesce(m.material_id, 0) material_id,
// 			coalesce(m.material_code, '') material_code,
// 			coalesce(m.supplier_id, 0) supplier_id,
// 			coalesce(m.pallet_pattern, 0) pallet_pattern,
// 			coalesce(s.supplier_code , '') supplier_code,
// 			coalesce(jd.end_of_stock, 0) end_of_stock
// 		from materials m
// 		left join suppliers s on m.supplier_id  = s.supplier_id
// 		left join (select * from jit_daily where is_deleted = false order by jit_daily_id desc) jd on jd.material_id = m.material_id
// 		where m.is_deleted = false
// 	`
// 	rows, err := db.ExecuteQuery(sqlx, query)
// 	if err != nil {
// 		return nil, err
// 	}

// 	for _, item := range rows {
// 		date := item["daily_date"].(time.Time)
// 		materialId := item["material_id"].(int64)
// 		materialCode := item["material_code"].(string)
// 		supplierId := item["supplier_id"].(int64)
// 		supplierCode := item["supplier_code"].(string)
// 		palletPattern := item["pallet_pattern"].(float64)
// 		qty := item["end_of_stock"].(float64)

// 		key := fmt.Sprintf("%s|%s", materialCode, date.Format("2006-01-02"))
// 		lastStockMat[key] = Material{
// 			MaterialId:    materialId,
// 			MaterialCode:  materialCode,
// 			SupplierId:    supplierId,
// 			SupplierCode:  supplierCode,
// 			PalletPattern: &palletPattern,
// 			Qty:           qty,
// 		}
// 	}

// 	return lastStockMat, nil
// }

// func CalculateUrgentStockDiff(jitMats []JitMaterial, lastEndStockMatMap map[string]Material, startCalDate time.Time) ([]JitMaterial, error) {
// 	for i := range jitMats {
// 		jitMat := &jitMats[i]
// 		materialCode := jitMat.MaterialCode

// 		for cDate := range jitMat.JitDates {
// 			jitDate := &jitMat.JitDates[cDate]
// 			lastEndStockMatQty := 0.0
// 			palletPattern := 0.0

// 			lastEndStockMatKey := fmt.Sprintf("%s|%s", materialCode, jitDate.Date.AddDate(0, 0, -1).Format("2006-01-02"))
// 			if lastEndStockMat, exists := lastEndStockMatMap[lastEndStockMatKey]; exists {
// 				lastEndStockMatQty = lastEndStockMat.Qty
// 				palletPattern = *lastEndStockMat.PalletPattern
// 			}

// 			if cDate == 0 {
// 				currentStock := jitMat.Stock.StockPlantQty + jitMat.Stock.StockSubconQty

// 				if currentStock < lastEndStockMatQty {
// 					requireQty := lastEndStockMatQty - currentStock
// 					requireQty = math.Ceil(requireQty/palletPattern) * palletPattern

// 					jitDate.UrgentQty = requireQty

// 					//first line
// 					for j := range jitDate.Lines {
// 						jitLine := &jitDate.Lines[j]
// 						jitLine.UrgenQty = requireQty
// 						jitLine.IsStockDiffQty = requireQty
// 						jitLine.IsStockDiff = true
// 						break
// 					}
// 				}

// 				break
// 			}
// 		}
// 	}

// 	return jitMats, nil
// }

// type AdjustLeadtime struct {
// 	Day    string
// 	Adjust int64
// }

// func GetAdjustLeadtimeRequire(sqlx *sqlx.DB) map[string]AdjustLeadtime {
// 	adjustLeadtimeMap := map[string]AdjustLeadtime{}

// 	adjusts, err := db.ExecuteQuery(sqlx, "select * from adjust_days")
// 	if err == nil {
// 		for _, adjustData := range adjusts {
// 			adjustLeadtimeMap[adjustData["day"].(string)] = AdjustLeadtime{
// 				Day:    adjustData["day"].(string),
// 				Adjust: adjustData["adjust"].(int64),
// 			}
// 		}
// 	}

// 	return adjustLeadtimeMap
// }

// func CalculateEstimate(jitMats []JitMaterial, adjustLeadtimeMap map[string]AdjustLeadtime, maxLineId int64, materialMap map[string]Material) ([]JitMaterial, error) {
// 	maxId := maxLineId + 1

// 	//Function
// 	createLinePlanKey := func(lineCode string, planId *int64) string {
// 		if planId == nil || *planId == 0 {
// 			return fmt.Sprintf("%s|", lineCode)
// 		}
// 		return fmt.Sprintf("%s|%d", lineCode, *planId)
// 	}

// 	calculateEstimateStock := func(jitDate *JitDate) float64 {
// 		return jitDate.BeginStock - jitDate.ProductionQty + jitDate.RequireQty + jitDate.UrgentQty
// 	}

// 	updateJitLineQty := func(lines []JitLine, lineCode string, planId *int64, productionId int64, qty float64, isUrgent bool) {
// 		for i, line := range lines {
// 			if line.LineCode == lineCode && line.PlanId == planId {
// 				lines[i].RefReuqestID = &productionId
// 				lines[i].PlanId = planId

// 				if isUrgent {
// 					lines[i].UrgenQty += qty
// 				} else {
// 					lines[i].RequireQty += qty
// 				}

// 				break
// 			}
// 		}
// 	}

// 	//Cal update prod and estimate
// 	for cMat := range jitMats {
// 		isStockPlant := true

// 		for cDate := range jitMats[cMat].JitDates {
// 			jitDate := &jitMats[cMat].JitDates[cDate]

// 			if cDate == 0 {
// 				jitDate.BeginStock = jitMats[cMat].Stock.StockPlantQty + jitMats[cMat].Stock.StockSubconQty

// 				if jitMats[cMat].Stock.StockPlantQty == 0 && jitMats[cMat].Stock.StockSubconQty > 0 {
// 					isStockPlant = false
// 				}

// 				jitDate.PlantSock = jitMats[cMat].Stock.StockPlantQty
// 				jitDate.SubconStock = jitMats[cMat].Stock.StockSubconQty
// 			} else {
// 				jitDate.BeginStock = jitMats[cMat].JitDates[cDate-1].EstimateStock

// 				if isStockPlant {
// 					jitDate.PlantSock = jitDate.BeginStock
// 				} else {
// 					jitDate.SubconStock = jitDate.BeginStock
// 				}
// 			}

// 			//Require Case
// 			if jitDate.BeginStock-jitDate.ProductionQty < 0 {
// 				var palletPattern float64 = 0

// 				if material, exists := materialMap[jitMats[cMat].MaterialCode]; exists {
// 					palletPattern = *material.PalletPattern
// 				}

// 				isUrgent := false
// 				leadTime := jitMats[cMat].LeadTime
// 				requireQty := math.Abs(jitDate.BeginStock - jitDate.ProductionQty)
// 				requireQty = math.Ceil(requireQty/palletPattern) * palletPattern
// 				currentDateCount := int64(cDate)
// 				startUpdateData := currentDateCount - leadTime

// 				shortDay := ""
// 				if startUpdateData >= 0 {
// 					shortDay = utils.GetShortWeekday(jitMats[cMat].JitDates[startUpdateData].Date)
// 				} else {
// 					shortDay = utils.GetShortWeekday(time.Now())
// 				}

// 				// shortDay = utils.GetShortWeekday(jitMats[cMat].JitDates[startUpdateData].Date)
// 				adjustLeadtimeKey := shortDay
// 				adjustLeadtime, adjustLeadtimeExist := adjustLeadtimeMap[adjustLeadtimeKey]

// 				// if startUpdateData < 0 {
// 				// 	startUpdateData = 0
// 				// 	isUrgent = true
// 				// } else if adjustLeadtimeExist {
// 				// 	startUpdateData += adjustLeadtime.Adjust

// 				// 	if startUpdateData < 0 {
// 				// 		startUpdateData = 0
// 				// 		isUrgent = true
// 				// 	}
// 				// }

// 				if adjustLeadtimeExist {
// 					startUpdateData += adjustLeadtime.Adjust
// 				}

// 				if startUpdateData < 0 {
// 					startUpdateData = 0
// 					isUrgent = true
// 				}

// 				for current := startUpdateData; current <= currentDateCount; current++ {
// 					if current == startUpdateData {
// 						if isUrgent {
// 							jitMats[cMat].JitDates[current].UrgentQty += requireQty
// 						} else {
// 							jitMats[cMat].JitDates[current].RequireQty += requireQty
// 						}

// 						requireLineMap := map[string]map[string]JitLine{}
// 						for _, requireJitLine := range jitMats[cMat].JitDates[current].Lines {
// 							lineCode := requireJitLine.LineCode
// 							linePlan := createLinePlanKey(lineCode, requireJitLine.PlanId)

// 							if _, exist := requireLineMap[lineCode]; !exist {
// 								requireLineMap[lineCode] = map[string]JitLine{}
// 							}

// 							requireLineMap[lineCode][linePlan] = requireJitLine
// 						}

// 						remainRequire := requireQty
// 						for i, productionJitLine := range jitDate.Lines {
// 							productionId := productionJitLine.id
// 							lineCode := productionJitLine.LineCode
// 							planId := productionJitLine.PlanId
// 							requireLine := productionJitLine.ProductionQty
// 							linePlan := createLinePlanKey(lineCode, planId)
// 							lineBlank := createLinePlanKey(lineCode, nil)

// 							if remainRequire < requireLine || i+1 == len(jitDate.Lines) {
// 								requireLine = remainRequire
// 							}

// 							if _, planExist := requireLineMap[lineCode][linePlan]; planExist {
// 								updateJitLineQty(jitMats[cMat].JitDates[current].Lines, lineCode, planId, productionId, requireLine, isUrgent)
// 							} else if _, blankExist := requireLineMap[lineCode][lineBlank]; blankExist {
// 								updateJitLineQty(jitMats[cMat].JitDates[current].Lines, lineCode, nil, productionId, requireLine, isUrgent)
// 							} else {
// 								newJitLine := JitLine{
// 									id:                  maxId,
// 									PlanId:              planId,
// 									RefReuqestID:        &productionId,
// 									MaterialCode:        jitMats[cMat].MaterialCode,
// 									DailyDate:           jitMats[cMat].JitDates[current].Date,
// 									LineCode:            lineCode,
// 									ProductionQty:       0,
// 									ProductionPlantQty:  0,
// 									ProductionSubconQty: 0,
// 									RequireQty:          0,
// 									UrgenQty:            0,
// 									ConfirmRequireQty:   0,
// 									ConfirmUrgentQty:    0,
// 									ConfirmRequireDate:  nil,
// 									ConfirmUrgentDate:   nil,
// 								}

// 								if isUrgent {
// 									newJitLine.UrgenQty = requireLine
// 								} else {
// 									newJitLine.RequireQty = requireLine
// 								}

// 								jitMats[cMat].JitDates[current].Lines = append(jitMats[cMat].JitDates[current].Lines, newJitLine)
// 								maxId++
// 							}

// 							remainRequire -= requireLine

// 							if remainRequire <= 0 {
// 								break
// 							}
// 						}
// 					} else {
// 						jitMats[cMat].JitDates[current].BeginStock = jitMats[cMat].JitDates[current-1].EstimateStock

// 						if isStockPlant {
// 							jitMats[cMat].JitDates[current].PlantSock = jitMats[cMat].JitDates[current].BeginStock
// 						} else {
// 							jitMats[cMat].JitDates[current].SubconStock = jitMats[cMat].JitDates[current].BeginStock
// 						}
// 					}

// 					jitMats[cMat].JitDates[current].EstimateStock = calculateEstimateStock(&jitMats[cMat].JitDates[current])
// 				}

// 				continue
// 			}

// 			jitDate.EstimateStock = calculateEstimateStock(jitDate)
// 		}
// 	}

// 	return jitMats, nil
// }

// func CalculateActual(jitMats []JitMaterial, confirmJitDateMap map[string][]JitDate) ([]JitMaterial, error) {
// 	for cJitMat, jitMat := range jitMats {
// 		for cJitDate, jitDate := range jitMat.JitDates {
// 			diff := (jitDate.RequireQty + jitDate.UrgentQty) - (jitDate.ConfirmRequireQty + jitDate.ConfirmUrgentQty)
// 			beginStock := jitDate.BeginStock
// 			confirmQty := 0.0
// 			productionQty := jitDate.ProductionQty
// 			planDate := jitDate.Date
// 			planDateStr := planDate.Format("2006-01-02")
// 			materialCode := jitMat.MaterialCode

// 			key := fmt.Sprintf("%s|%s|%s", materialCode, planDateStr, "R")
// 			if confirmJit, exist := confirmJitDateMap[key]; exist {
// 				for _, item := range confirmJit {
// 					confirmQty += item.ConfirmQty
// 				}
// 			}

// 			key = fmt.Sprintf("%s|%s|%s", materialCode, planDateStr, "U")
// 			if confirmJit, exist := confirmJitDateMap[key]; exist {
// 				for _, item := range confirmJit {
// 					confirmQty += item.ConfirmUrgentQty
// 				}
// 			}

// 			if cJitDate != 0 {
// 				beginStock = jitMats[cJitMat].JitDates[cJitDate-1].EndStock
// 			}

// 			endStock := beginStock - productionQty + confirmQty

// 			jitMats[cJitMat].JitDates[cJitDate].Diff = diff
// 			jitMats[cJitMat].JitDates[cJitDate].EndStock = endStock
// 		}
// 	}

// 	return jitMats, nil
// }

// func GetLineMap(sqlx *sqlx.DB, condition []string) (map[string]Line, error) {
// 	rsMap := map[string]Line{}

// 	query := fmt.Sprintf(`
// 		select jlh.line_header_id as line_id
// 			,  jlh.line_header_name as line_code
// 		from jit_line_headers jlh
// 		where jlh.line_header_name in ('%s')
// 	`, strings.Join(condition, `','`))
// 	rows, err := db.ExecuteQuery(sqlx, query)
// 	if err != nil {
// 		return nil, err
// 	}

// 	for _, item := range rows {
// 		lineId := item["line_id"].(int64)
// 		lineCode := item["line_code"].(string)

// 		key := lineCode
// 		rsMap[key] = Line{
// 			LineId:   lineId,
// 			LineCode: lineCode,
// 		}
// 	}

// 	return rsMap, nil
// }

// func GetMatrialMap(sqlx *sqlx.DB, condition []string) (map[string]Material, error) {
// 	rsMap := map[string]Material{}

// 	query := fmt.Sprintf(`
// 		select m.material_id ,m.material_code , m.supplier_id, coalesce(m.pallet_pattern, 0) pallet_pattern
// 		,  coalesce(s.supplier_code , '') as supplier_code
// 		from materials m
// 		left join suppliers s on m.supplier_id  = s.supplier_id
// 		where m.is_deleted = false and m.material_code in ('%s')
// 	`, strings.Join(condition, `','`))
// 	println(query)
// 	rows, err := db.ExecuteQuery(sqlx, query)
// 	if err != nil {
// 		return nil, err
// 	}

// 	for _, item := range rows {
// 		materialId := item["material_id"].(int64)
// 		materialCode := item["material_code"].(string)
// 		supplierId := item["supplier_id"].(int64)
// 		supplierCode := item["supplier_code"].(string)
// 		palletPattern := item["pallet_pattern"].(float64)

// 		key := materialCode
// 		rsMap[key] = Material{
// 			MaterialId:    materialId,
// 			MaterialCode:  materialCode,
// 			SupplierId:    supplierId,
// 			SupplierCode:  supplierCode,
// 			PalletPattern: &palletPattern,
// 		}
// 	}

// 	return rsMap, nil
// }

// func ConvertToJitDailyDB(jitMats []JitMaterial, lineMap map[string]Line, materialMap map[string]Material) ([]JitDaily, error) {
// 	jitDailys := []JitDaily{}

// 	for _, jitMat := range jitMats {
// 		for _, jitDate := range jitMat.JitDates {
// 			for _, jitLine := range jitDate.Lines {
// 				lineCode := jitLine.LineCode
// 				materialCode := jitLine.MaterialCode
// 				productionQty := jitLine.ProductionQty
// 				isGenerate := false
// 				lineId := int64(0)
// 				materialId := int64(0)
// 				supplierId := int64(0)
// 				requiredQty := jitLine.RequireQty
// 				urgentQty := jitLine.UrgenQty

// 				var planId int64
// 				if jitLine.PlanId != nil && *jitLine.PlanId > 0 && jitLine.ProductionQty > 0 {
// 					planId = *jitLine.PlanId
// 				}

// 				if line, exist := lineMap[lineCode]; exist {
// 					lineId = line.LineId
// 				}

// 				if material, exist := materialMap[materialCode]; exist {
// 					materialId = material.MaterialId
// 					supplierId = material.SupplierId
// 				}

// 				jitDaily := JitDaily{
// 					JitDailyID:         jitLine.id,
// 					JitDailyPlanID:     planId,
// 					MaterialID:         materialId,
// 					LineID:             lineId,
// 					SupplierID:         supplierId,
// 					DailyDate:          jitDate.Date,
// 					BeginStock:         jitDate.BeginStock,
// 					PlantStock:         jitDate.PlantSock,
// 					SubconStock:        jitDate.SubconStock,
// 					PlantEndOfStock:    jitDate.EstimateStock,
// 					EndOfStock:         jitDate.EndStock,
// 					ProductQty:         productionQty,
// 					PlantQty:           jitLine.ProductionPlantQty,
// 					SubconQty:          jitLine.ProductionSubconQty,
// 					RequiredQty:        requiredQty,
// 					UrgentQty:          urgentQty,
// 					ConfQty:            jitLine.ConfirmRequireQty,
// 					ConfDate:           jitLine.ConfirmRequireDate,
// 					ConfUrgentDate:     jitLine.ConfirmUrgentDate,
// 					OriginalJitDailyID: jitLine.RefReuqestID,
// 					IsDeleted:          false,
// 					IsGenerate:         &isGenerate,
// 					CreatedDate:        time.Now(),
// 					UpdatedDate:        time.Now(),
// 				}

// 				jitDailys = append(jitDailys, jitDaily)
// 			}
// 		}
// 	}

// 	return jitDailys, nil
// }

// func ConvertToProcessDB(jitPlans []JitDilyPlan, lineMap map[string]Line, materialMap map[string]Material) ([]JitProcess, error) {
// 	jitProcesses := []JitProcess{}

// 	for _, plan := range jitPlans {
// 		id := plan.PlanId
// 		lineCode := plan.LineCode
// 		lineId := int64(0)
// 		materialCode := plan.MaterialCode
// 		requestQty := plan.RequestQty
// 		planStart := plan.PlanDate
// 		planEnd := plan.EndPlanDate

// 		if lineCode != `` {
// 			lineMap, lineExist := lineMap[lineCode]

// 			if !lineExist {
// 				return nil, fmt.Errorf("line not found for lineCode: %s", lineCode)
// 			}

// 			lineId = lineMap.LineId
// 		}

// 		materialMap, materialExist := materialMap[materialCode]
// 		if !materialExist {
// 			return nil, fmt.Errorf("material not found for materialCode: %s", materialCode)
// 		}

// 		if planEnd == nil {
// 			planEnd = &planStart
// 		}

// 		jitProcess := JitProcess{
// 			JitProcessID:    id,
// 			LineID:          lineId,
// 			FGMaterialID:    materialMap.MaterialId,
// 			LineName:        lineCode,
// 			FGCode:          materialCode,
// 			FGDescription:   fmt.Sprintf("Plan for %s", materialCode),
// 			PlanQty:         requestQty,
// 			ProductSAP:      materialCode,
// 			StartTime:       planStart,
// 			FinishTime:      planEnd,
// 			TotalMinuteUsed: 0,
// 			IsBreak:         false,
// 			ImportID:        0,
// 			IsDaily:         true,
// 			IsProcess:       true,
// 			IsDeleted:       false,
// 			UpdatedBy:       0,
// 			UpdatedDate:     time.Now(),
// 			CreatedBy:       0,
// 			CreatedDate:     time.Now(),
// 		}

// 		jitProcesses = append(jitProcesses, jitProcess)
// 	}

// 	return jitProcesses, nil
// }

// func CreateJitDaily(gormx *gorm.DB, sqlx *sqlx.DB, jitProcesses []JitProcess, jitDailys []JitDaily, startDate time.Time) error {
// 	mats := []int64{}
// 	matCheck := map[int64]bool{}
// 	for _, item := range jitDailys {
// 		materialId := item.MaterialID
// 		if _, exist := matCheck[materialId]; !exist {
// 			mats = append(mats, materialId)
// 			matCheck[materialId] = true
// 		}
// 	}

// 	tx := gormx.Begin()

// 	var allProcessidInsert []string

// 	// Insert JitProcesses
// 	var maxProcessID int64
// 	if err := tx.Raw("SELECT COALESCE(MAX(jit_process_id), 0) FROM jit_process").Scan(&maxProcessID).Error; err != nil {
// 		tx.Rollback()
// 		return fmt.Errorf("failed to get max process id: %w", err)
// 	}

// 	for i := range jitProcesses {
// 		jitProcesses[i].JitProcessID += maxProcessID
// 		allProcessidInsert = append(allProcessidInsert, strconv.Itoa(int(jitProcesses[i].JitProcessID)))
// 	}

// 	if err := tx.Create(&jitProcesses).Error; err != nil {
// 		tx.Rollback()
// 		return fmt.Errorf("failed to insert JitProcesses: %w", err)
// 	}

// 	// Insert JitDailys
// 	var maxDailyID int64
// 	if err := tx.Raw("SELECT COALESCE(MAX(jit_daily_id), 0) AS max_id FROM jit_daily").Scan(&maxDailyID).Error; err != nil {
// 		tx.Rollback()
// 		return fmt.Errorf("failed to get max id: %w", err)
// 	}

// 	for i := range jitDailys {
// 		jitDailys[i].JitDailyID += maxDailyID

// 		if jitDailys[i].OriginalJitDailyID != nil {
// 			*jitDailys[i].OriginalJitDailyID += maxDailyID
// 		}

// 		if jitDailys[i].JitDailyPlanID != 0 {
// 			jitDailys[i].JitDailyPlanID += maxProcessID
// 		}
// 	}

// 	if err := tx.Model(&JitDaily{}).
// 		Where("daily_date >= ?", startDate).
// 		Updates(map[string]interface{}{"is_deleted": true}).Error; err != nil {
// 		tx.Rollback()
// 		return fmt.Errorf("failed to update is_deleted status: %w", err)

// 	}

// 	if err := tx.CreateInBatches(&jitDailys, 1000).Error; err != nil {
// 		tx.Rollback()
// 		return fmt.Errorf("failed to insert JitDailys: %w", err)
// 	}

// 	if err := tx.Commit().Error; err != nil {
// 		return fmt.Errorf("failed to commit transaction: %w", err)
// 	}

// 	sql := fmt.Sprintf("select jit_send_daily_required_email('{%s}')", strings.Join(allProcessidInsert, ","))
// 	_, err := db.ExecuteQuery(sqlx, sql)
// 	if err != nil {
// 		return fmt.Errorf("failed to push process id to require: %w", err)
// 	}

// 	return nil
// }
